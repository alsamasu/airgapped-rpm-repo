#!/bin/bash
# rpmserverctl - Main control script for Airgapped RPM Repository System
#
# Usage: rpmserverctl <command> [options]
#
# Commands:
#   init-external    Initialize external builder environment
#   init-internal    Initialize internal publisher environment
#   status           Show system status
#   version          Show version information

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSION="1.0.0"

# Load common functions
# shellcheck source=scripts/common/logging.sh
source "${SCRIPT_DIR}/scripts/common/logging.sh"
# shellcheck source=scripts/common/validation.sh
source "${SCRIPT_DIR}/scripts/common/validation.sh"

# Configuration
DATA_DIR="${RPMSERVER_DATA_DIR:-/data}"
LOG_DIR="${RPMSERVER_LOG_DIR:-/var/log/rpmserver}"
KEYS_DIR="${DATA_DIR}/keys"
MIRROR_DIR="${DATA_DIR}/mirror"
MANIFESTS_DIR="${DATA_DIR}/manifests"
BUNDLES_DIR="${DATA_DIR}/bundles"
REPOS_DIR="${DATA_DIR}/repos"
STAGING_DIR="${DATA_DIR}/staging"
LIFECYCLE_DIR="${DATA_DIR}/lifecycle"

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

usage() {
    cat << EOF
Airgapped RPM Repository System Control Script

Usage: rpmserverctl <command> [options]

Commands:
  init-external       Initialize external builder environment
  init-internal       Initialize internal publisher environment
  status              Show system status
  version             Show version information
  help                Show this help message

Environment Variables:
  RPMSERVER_DATA_DIR  Data directory (default: /data)
  RPMSERVER_LOG_DIR   Log directory (default: /var/log/rpmserver)
  RPMSERVER_MODE      Operating mode: external|internal (auto-detected)

Examples:
  rpmserverctl init-external
  rpmserverctl init-internal
  rpmserverctl status

EOF
}

init_external() {
    log_info "Initializing external builder environment..."

    # Create directory structure
    local dirs=(
        "${MIRROR_DIR}"
        "${MIRROR_DIR}/rhel8/x86_64/baseos"
        "${MIRROR_DIR}/rhel8/x86_64/appstream"
        "${MIRROR_DIR}/rhel9/x86_64/baseos"
        "${MIRROR_DIR}/rhel9/x86_64/appstream"
        "${MANIFESTS_DIR}/incoming"
        "${MANIFESTS_DIR}/processed"
        "${MANIFESTS_DIR}/index"
        "${BUNDLES_DIR}"
        "${REPOS_DIR}"
        "${STAGING_DIR}"
        "${KEYS_DIR}"
        "${LOG_DIR}"
    )

    for dir in "${dirs[@]}"; do
        if [[ ! -d "${dir}" ]]; then
            mkdir -p "${dir}"
            log_info "Created directory: ${dir}"
        fi
    done

    # Create GPG keyring directory
    if [[ ! -d "${KEYS_DIR}/.gnupg" ]]; then
        mkdir -p "${KEYS_DIR}/.gnupg"
        chmod 700 "${KEYS_DIR}/.gnupg"
        log_info "Created GPG keyring directory"
    fi

    # Create configuration file
    local config_file="${DATA_DIR}/external.conf"
    if [[ ! -f "${config_file}" ]]; then
        cat > "${config_file}" << 'CONF'
# External Builder Configuration
# Generated by rpmserverctl init-external

# Repository profiles to sync
PROFILES="rhel8 rhel9"

# Architectures to sync
ARCHITECTURES="x86_64"

# RHEL 8 repositories
RHEL8_REPOS="rhel-8-for-x86_64-baseos-rpms rhel-8-for-x86_64-appstream-rpms"

# RHEL 9 repositories
RHEL9_REPOS="rhel-9-for-x86_64-baseos-rpms rhel-9-for-x86_64-appstream-rpms"

# Sync options
SYNC_NEWEST_ONLY=true
SYNC_DELETE=false

# GPG signing key ID (set after key generation)
GPG_KEY_ID=""

# Bundle versioning
BUNDLE_VERSION_FORMAT="YYYY-MM-DD-NNN"
CONF
        log_info "Created configuration file: ${config_file}"
    fi

    # Create manifest index
    local index_file="${MANIFESTS_DIR}/index/manifest_index.json"
    if [[ ! -f "${index_file}" ]]; then
        echo '{"hosts": {}, "last_updated": null}' > "${index_file}"
        log_info "Created manifest index"
    fi

    log_success "External builder environment initialized"
    log_info "Next steps:"
    log_info "  1. Register with subscription-manager: make sm-register"
    log_info "  2. Enable repositories: make enable-repos"
    log_info "  3. Sync content: make sync"
}

init_internal() {
    log_info "Initializing internal publisher environment..."

    # Create directory structure
    local dirs=(
        "${BUNDLES_DIR}/incoming"
        "${BUNDLES_DIR}/verified"
        "${BUNDLES_DIR}/archive"
        "${REPOS_DIR}"
        "${LIFECYCLE_DIR}/dev"
        "${LIFECYCLE_DIR}/prod"
        "${KEYS_DIR}"
        "${STAGING_DIR}"
        "${LOG_DIR}"
        "${DATA_DIR}/client-config"
    )

    for dir in "${dirs[@]}"; do
        if [[ ! -d "${dir}" ]]; then
            mkdir -p "${dir}"
            log_info "Created directory: ${dir}"
        fi
    done

    # Create configuration file
    local config_file="${DATA_DIR}/internal.conf"
    if [[ ! -f "${config_file}" ]]; then
        cat > "${config_file}" << 'CONF'
# Internal Publisher Configuration
# Generated by rpmserverctl init-internal

# Base URL for clients
BASE_URL="http://repo.internal.local:8080"

# HTTP server configuration
HTTP_PORT=8080
HTTPS_PORT=8443

# Lifecycle channels
LIFECYCLE_CHANNELS="dev prod"
DEFAULT_CHANNEL="dev"

# Repository structure
REPO_STRUCTURE="lifecycle/CHANNEL/PROFILE/ARCH/REPOID"

# Verification settings
VERIFY_GPG_SIGNATURES=true
VERIFY_BOM_CHECKSUMS=true
REQUIRE_SIGNATURE_VERIFICATION=true

# Retention settings
BUNDLE_RETENTION_COUNT=5
CONF
        log_info "Created configuration file: ${config_file}"
    fi

    # Create lifecycle metadata
    for channel in dev prod; do
        local meta_file="${LIFECYCLE_DIR}/${channel}/metadata.json"
        if [[ ! -f "${meta_file}" ]]; then
            cat > "${meta_file}" << METADATA
{
    "channel": "${channel}",
    "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "current_bundle": null,
    "history": []
}
METADATA
            log_info "Created lifecycle metadata: ${channel}"
        fi
    done

    log_success "Internal publisher environment initialized"
    log_info "Next steps:"
    log_info "  1. Import GPG public key to ${KEYS_DIR}/"
    log_info "  2. Import bundle: make import BUNDLE_PATH=/path/to/bundle.tar.gz"
    log_info "  3. Verify bundle: make verify"
    log_info "  4. Publish to dev: make publish LIFECYCLE=dev"
}

show_status() {
    echo -e "${BLUE}Airgapped RPM Repository System Status${NC}"
    echo "========================================"
    echo ""

    # Detect mode
    local mode="unknown"
    if [[ -f "${DATA_DIR}/external.conf" ]]; then
        mode="external"
    elif [[ -f "${DATA_DIR}/internal.conf" ]]; then
        mode="internal"
    fi
    echo -e "Mode: ${GREEN}${mode}${NC}"
    echo ""

    # Directory sizes
    echo "Directory Sizes:"
    if [[ -d "${MIRROR_DIR}" ]]; then
        local mirror_size
        mirror_size=$(du -sh "${MIRROR_DIR}" 2>/dev/null | cut -f1 || echo "N/A")
        echo "  Mirror:    ${mirror_size}"
    fi
    if [[ -d "${REPOS_DIR}" ]]; then
        local repos_size
        repos_size=$(du -sh "${REPOS_DIR}" 2>/dev/null | cut -f1 || echo "N/A")
        echo "  Repos:     ${repos_size}"
    fi
    if [[ -d "${BUNDLES_DIR}" ]]; then
        local bundles_size
        bundles_size=$(du -sh "${BUNDLES_DIR}" 2>/dev/null | cut -f1 || echo "N/A")
        echo "  Bundles:   ${bundles_size}"
    fi
    echo ""

    # Manifest count (external mode)
    if [[ -d "${MANIFESTS_DIR}/processed" ]]; then
        local manifest_count
        manifest_count=$(find "${MANIFESTS_DIR}/processed" -name "*.json" 2>/dev/null | wc -l)
        echo "Processed Manifests: ${manifest_count}"
    fi

    # Bundle count
    if [[ -d "${BUNDLES_DIR}" ]]; then
        local bundle_count
        bundle_count=$(find "${BUNDLES_DIR}" -name "*.tar.gz" 2>/dev/null | wc -l)
        echo "Bundles: ${bundle_count}"
    fi

    # Lifecycle status (internal mode)
    if [[ -d "${LIFECYCLE_DIR}" ]]; then
        echo ""
        echo "Lifecycle Channels:"
        for channel in dev prod; do
            local meta_file="${LIFECYCLE_DIR}/${channel}/metadata.json"
            if [[ -f "${meta_file}" ]]; then
                local current_bundle
                current_bundle=$(jq -r '.current_bundle // "none"' "${meta_file}" 2>/dev/null || echo "unknown")
                echo "  ${channel}: ${current_bundle}"
            fi
        done
    fi

    # GPG key status
    echo ""
    echo "GPG Key Status:"
    if command -v gpg &>/dev/null; then
        local key_count
        key_count=$(gpg --homedir "${KEYS_DIR}/.gnupg" --list-keys 2>/dev/null | grep -c "^pub" || echo "0")
        if [[ "${key_count}" -gt 0 ]]; then
            echo -e "  ${GREEN}${key_count} key(s) available${NC}"
        else
            echo -e "  ${YELLOW}No keys configured${NC}"
        fi
    else
        echo -e "  ${YELLOW}GPG not available${NC}"
    fi
}

show_version() {
    echo "Airgapped RPM Repository System"
    echo "Version: ${VERSION}"
    echo ""
    echo "Components:"
    echo "  rpmserverctl: ${VERSION}"
    if command -v createrepo_c &>/dev/null; then
        echo "  createrepo_c: $(createrepo_c --version 2>&1 | head -1)"
    fi
    if command -v gpg &>/dev/null; then
        echo "  gpg: $(gpg --version | head -1)"
    fi
    if command -v dnf &>/dev/null; then
        echo "  dnf: $(dnf --version | head -1)"
    fi
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true

    case "${command}" in
        init-external)
            init_external "$@"
            ;;
        init-internal)
            init_internal "$@"
            ;;
        status)
            show_status "$@"
            ;;
        version|--version|-v)
            show_version
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            log_error "Unknown command: ${command}"
            usage
            exit 1
            ;;
    esac
}

main "$@"
